function [ out_h, out_l ] = envelopes( x, type )
% функция вычислет верхнюю и нижнюю 
% огибающие входного сигнала
% Аргументы :
% x - одномерный сигнал
% type - тип алгоритма используемый для вычисления огибающей
%            возможные значения: 'hilbert', 'interp' 
%
% Возвращаемые значения :
% out_h - вершняя огибающая 
% out_l - нижняя огибающая

switch type
    case 'hilbert'
        % реализация через преобразование Гильберта
        out_h = abs(sqrt(x.^2 + hilbert(x).^2));
        out_l = -out_h;
    case 'interp'
        % реализация через линейную 
        % аппроксимацию огибающей
        
        % вычисление производной
        dx = x(2:end) - x(1:end-1);
        
        
        % находим экстремумы
        z = [];
        for k = 2:length(dx)
            if dx(k-1) * dx(k)<0
                % здесь позиции экстремумов
                z = [z k];
            end
        end
        
        
        % Полученную сетку позиций экстремумов надо
        % разделить на максимумы и минимумы.
        % Предположим, что первый из экстреммумов - максимум
        % если это не так, то в конце поменяем местами.
        % разделяем на максимумы
        hz = z(1:2:end);
        % и минимумы
        lz = z(2:2:end);
        
        % Для правильного интерполирования надо добавить
        % начало и конец в сетку
        if hz(1) ~= 1
            hz = [1 hz];
        end
        if hz(end) ~= length(x)
            hz = [hz length(x)];
        end
        if lz(1) ~= 1
            lz = [1 lz];
        end
        if lz(end) ~= length(x)
            lz = [lz length(x)];
        end
        
        % интерполируем максимумы и минимумы отдельно
        %получая верхнюю и  нижнюю огибающие
        out_h = interp1(hz,x(hz), [1:length(x)]);
        out_l = interp1(lz,x(lz), [1:length(x)]);
        
        % Поскольку проверки на кратность не было, то верхняя
        % огибающаяя может превращаться в нижнюю и наоборот
        % в точках, где вторая производная обращается в ноль.
        % Чтобы избежать этого поменяем местами части
        % огибающих, в которых нижняя больше верхней.
        for k = 1 : length(x)
            if out_h(k) < out_l(k)
                tmp = out_h(k);
                out_h(k) = out_l(k);
                out_l(k) = tmp;
            end
        end
end
end

